Final exam
Bo Yu ( byu1@stevens.edu)

1)

	Unix Shell is a program execution environment. It accepts user's
	command, execute the command, then wait for the next user's input. 
	
	When user input a command, the shell will keep the whole input into
	a buffer, and parse the input, understand each token, such as program
	name, program arguments, redirection signs like '|', '<' or '>'.

	If the input doesn't contain redirection signs, then shell will create
	a new child process, and call the exec() function to execute the user's
	command within the child process; at the same time, the parent process
	will wait for child's termination. And then, shell will wait for the
	next user's input.
	
	If the input contains redirection signs, shell should analyze them 
	carefully, to determine who is the input side, who is the output side.
	Let's say input side is A, and output side is B. More complexity, shell
	may resolve the situation which involved more redirection signs.

	With a command contains redirection signs, shell will create a pipeline 
	in order to communicate between two processes. Then shell will create a
	new process to handle B as we mentioned above. 
	
	In the parent process, shell will make sure that the A's execution output
	will re-direct to child process's input. Then parent process will 
	execute A, and then wait for child process's termination.
	
	In the child process, shell will make sure that the input will come from 
	parent's output. It can be achieved by manipulating pipeline. Then use 
	exec() to execute B. After B has been executed, shell will go to parent 
	process, and wait for the next user's input.
	
	Usually user may cancels the program's execution by input 'ctrl+C'. To
	handle this situlation, the shell should register a signal handler.
	In the handler function, shell should kill the executing process.

	Sometimes use will change the working directory, so shell should change
	it carefully to take care of the pathname.

	Shell will be quit when user input 'exit' command or when system shutdown, 
	shell should do some cleanup before exit.

2)

	shell entry:
		register a signal handler to handle shell termination by 'Ctrl+C'

		while ( get_input() )
		{
			parse_input() to extract program name, arguments, or
			redirection signs
			
			if input equals to 'exit' then exit 

			create a pipe to communicate between two processes

			fork a child process

			[in the parent process]
				if input contains redirection characters such as '|' '<' '>'
					let output redirect to child's input
					execute programA by another fork
				endif

				wait for child's termination
			
			[in the child process]
				if input contains redirection characters such as '|' '<' '>'
					direct input from parent's output
					execute programB
				endif
		}

3) 

	One deficiency with creat is that the file is opened only for writing.
	If we were creating a temporary file that we wanted to write and then 
	read back, we had to call creat, close, and then open.

	Another issue is that before we writing content to a file, other 
	processes may write something to our file, so inconsistency may happened.

4)

	Disk is filling up.
	The file size limit for a given process has been exceeded.

5)

	Randomly. No body can make sure who runs first.

6)

	In the pwd.h header file, numerical group ID is presented by gid_t, 
	and gid_t is 4 byte, so the maximun group id is 2^32, then 2^32
	groups may a single user be in.

7)
	
	Use API in the grp.h 
		struct group *getgrnam (const char *name);
	
	The filed gr_mem of struct group is an array of pointers to the user names
	that belong to this group.

8)

	
9)
	
	File Descriptor Table.
	Current working directory.
	Process State.
	Stack Segment Pointer.

10)
	1.
	#include <sys/socket.h>
	accept();
	If sockfd is in nonblocking mode, accept will return -1.

	2.
	read(STDIN_FILENO, buf, sizeof(buf));
	Use this to avoid blocking: 
	set_fl ( STDIN_FILENO, O_NONBLOCK );
	
	3. 
	write ( STDOUT_FILENO, buf, sizeof(buf) );
	Use this to avoid blocking:
	set_fl ( STDOUT_FILENO, O_NONBLOCK );

	4.
	open ();
	Use this to avoid blocking:
	select ();

11)

	
12)

	This program use chdir() to change the current working directory
	of the calling process. But the current working directory cannot
	affect processes that invoke the process that executes the chdir.
	So shell's current working directory cannot be changed.

13)

	For the fist attempt ./a.out
	fork() will create a new process, and the program will have two 
	seprate roads, the parent one will output "write4" after 2 seconds,
	and child will output "write3" and "write4"

	For the second attempt ./a.out | cat
	printf () and write(STDOUT_FILENO) means differently. This time,
	printf () will redirect to the input of cat, and write(STDOUT_FILENO)
	still will output to the Standard Output.
	The first two lines "write1" and "write3" are outputed by 
	write(STDOUT_FILENO).
	The following lines are send to cat, then output by cat.

14)

	See the subdirectory 14

15)
	
	See the subdirectory 15

16)

	See the subdirectory 16

